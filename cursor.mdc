---
alwaysApply: true
---

# AI-Powered Treatment Plan Assistant
## Root Documentation & Developer Onboarding Guide

---

## 1. Application Overview

### What is This Application?

The **AI-Powered Treatment Plan Assistant** is a multi-step clinical wizard platform designed to empower healthcare professionals with intelligent decision-making support. The platform reduces medical errors through automated safety checks, flagging drug interactions, contraindications, dosage issues, and treatment appropriateness.

The system leverages AI (specifically Google's Gemini) to analyze patient data and generate structured, parseable treatment recommendations. All patient medical records are securely stored and associated with their user ID, enabling the system to learn from historical patterns over time. This continuous learning helps improve treatment recommendations and proactively identify potential complications that could lead to serious consequences.

### Core Value Proposition

- **Error Reduction**: Automated safety checks prevent medication errors before they occur
- **Intelligent Recommendations**: AI-powered treatment plan suggestions based on patient history and clinical data
- **Pattern Learning**: System learns from patient patterns to improve recommendations over time
- **Risk Mitigation**: Proactive identification of complications and drug interactions
- **Structured Output**: Parseable JSON schema output for seamless integration with clinical workflows

---

## 2. What We Do

### Primary Functions

1. **Treatment Plan Recommendation**
   - Generate AI-powered treatment plans with medication, dosage, and duration recommendations
   - Provide structured, parseable output (JSON schema) for clinical systems
   - Display recommendations in an intuitive, user-friendly UI

2. **Safety Risk Assessment**
   - Calculate and display safety risk scores (Low, Medium, High)
   - Flag contraindications and drug-drug interactions
   - Cross-reference recommendations against drug interaction databases

3. **Clinical Decision Support**
   - Provide alternative treatment options when primary recommendations have risks
   - Offer explanations and rationale for each recommendation
   - Include confidence scores per recommendation

4. **Patient Data Management**
   - Store and manage patient medical records securely
   - Associate all data with patient user IDs
   - Enable historical pattern analysis for improved recommendations

5. **Doctor Workflow Integration**
   - Support doctor review, modification, and approval of AI-generated plans
   - Enable seamless editing of treatment plans before finalization
   - Provide clear summary views for final treatment decisions

---

## 3. Features We Need

### 3.1 Core Features

#### 3.1.1 Treatment Plan Generation
- **Medication Recommendations**: AI-suggested medications based on patient condition
- **Dosage Specifications**: Precise dosage recommendations with units
- **Duration Guidelines**: Clear duration for medication administration
- **Structured Output**: JSON schema format for all recommendations

#### 3.1.2 Safety & Risk Management
- **Risk Score Calculation**: 
  - Low risk
  - Medium risk
  - High risk
- **Contraindication Flagging**: Automatic detection of contraindications
- **Drug Interaction Detection**: Real-time drug-drug interaction checking
- **Dosage Appropriateness**: Validation of recommended dosages
- **Database Integration**: Cross-checking against drug interaction/contraindication databases (PostgreSQL, API, etc.)

#### 3.1.3 Clinical Decision Support
- **Alternative Treatment Options**: Provide backup treatment plans when primary options have risks
- **Confidence Scores**: Display confidence levels per recommendation
- **Rationale & Explanations**: Clear explanations for each recommendation
- **Alternative Treatment Paths**: Multiple treatment options with risk assessments

#### 3.1.4 User Interface (Critical Requirements)
- **Risk-First Display**: Show critical risks first, followed by details, then rationale
- **Approval Workflow**: Doctor can approve, modify, or reject AI-generated treatment plans
- **Smooth Navigation**: Intuitive UI to prevent burnout and frustration
- **Multi-Step Wizard**: Guided clinical workflow through intake to final summary

### 3.2 User Flow

**Critical User Journey:**
```
Intake → AI Analysis → Doctor Review/Edit → Final Summary
```

1. **Intake Phase**
   - Patient data collection
   - Medical history input
   - Current condition documentation

2. **AI Analysis Phase**
   - Gemini LLM processes patient data
   - Generates treatment plan recommendations
   - Performs safety checks and risk assessments

3. **Doctor Review/Edit Phase**
   - Doctor reviews AI-generated plan
   - Can approve, modify, or reject recommendations
   - Edit medications, dosages, or durations
   - Review flagged risks and alternatives

4. **Final Summary Phase**
   - Display approved/modified treatment plan
   - Show final risk assessments
   - Generate structured output for clinical records

### 3.3 Data Management Features
- **Patient Record Storage**: Secure storage of all patient medical records
- **User ID Association**: All data linked to patient user IDs
- **Pattern Learning**: System learns from historical patient patterns
- **Complication Analysis**: Identify and address potential complications proactively

---

## 4. High-Level Architecture Pattern

### 4.1 Architecture Overview

**Architecture Type**: Monolithic Architecture

**Architectural Pattern**: Four-Layer Architecture Pattern

This architecture provides clear separation of concerns and makes the codebase maintainable and scalable for new developers.

### 4.2 Layer Structure

#### Layer 1: Presentation/UI Layer
- **Location**: `app/`, `components/`
- **Responsibility**: 
  - User interface components
  - User interactions and form handling
  - Display of data and recommendations
  - UI state management (Zustand for client-side state)
- **Technologies**: React, Next.js App Router, Tailwind CSS

#### Layer 2: Hook Layer (Custom Hooks)
- **Location**: `hooks/` (to be created)
- **Responsibility**:
  - Custom React hooks for data fetching and mutations
  - Encapsulates business logic for UI components
  - Manages loading states, error handling
  - Acts as bridge between UI and Services
- **Pattern**: 
  - Fetching: `useQuery`, `useFetch` hooks
  - Mutations: `useMutation`, `useAction` hooks

#### Layer 3: Services Layer
- **Location**: `services/` or `lib/services/` (to be created)
- **Responsibility**:
  - Business logic implementation
  - Data transformation and validation
  - Integration with external APIs (Gemini, drug databases)
  - Error handling and retry logic
- **Pattern**: Service classes or modules that handle specific domains
  - `TreatmentPlanService`
  - `DrugInteractionService`
  - `PatientRecordService`
  - `AIService` (Gemini integration)

#### Layer 4: API Layer
- **Location**: `app/api/` (Next.js API routes)
- **Responsibility**:
  - RESTful API endpoints
  - Request/response handling
  - Authentication/authorization (Next-Auth)
  - Database operations via Prisma ORM
- **Pattern**: Next.js API routes or Route Handlers

### 4.3 Data Flow Patterns

#### Fetching Data (Read Operations)
```
API Route → Services Layer → Hook Layer → Presentation/UI Layer
```

**Example Flow:**
1. UI component calls a custom hook (e.g., `useTreatmentPlan`)
2. Hook calls a service method (e.g., `TreatmentPlanService.getPlan()`)
3. Service makes API call to Next.js API route (e.g., `GET /api/treatment-plans`)
4. API route uses Prisma to query database
5. Data flows back through layers with transformations at each level

#### Mutating Data (Write Operations)
```
Presentation/UI Layer → Action Hook → Services Layer → API Route
```

**Example Flow:**
1. User submits form in UI component
2. Component calls mutation hook (e.g., `useCreateTreatmentPlan`)
3. Hook calls service method (e.g., `TreatmentPlanService.createPlan()`)
4. Service validates and transforms data, then calls API route (e.g., `POST /api/treatment-plans`)
5. API route uses Prisma to persist to database
6. Success/error response flows back through layers

### 4.4 Technology Stack

#### Frontend
- **Framework**: Next.js 16 (App Router)
- **UI Library**: React 19
- **State Management**: Zustand (for client-side state)
- **Styling**: Tailwind CSS 4
- **UI Components**: shadcn/ui (via components.json)

#### Backend
- **Runtime**: Node.js
- **API**: Next.js API Routes / Route Handlers
- **Authentication**: Next-Auth
- **ORM**: Prisma 6
- **Database**: PostgreSQL (via Supabase)

#### AI & External Services
- **AI Model**: Google Gemini
- **Drug Database**: PostgreSQL/API for drug interactions and contraindications

#### Development Tools
- **Language**: TypeScript 5
- **Linting**: ESLint
- **Package Manager**: npm

### 4.5 Directory Structure (Recommended)

```
/
├── app/                          # Next.js App Router
│   ├── api/                      # API routes (Layer 4)
│   │   ├── treatment-plans/
│   │   ├── patients/
│   │   └── drug-interactions/
│   ├── (auth)/                   # Auth routes
│   ├── dashboard/                # Main application pages
│   ├── layout.tsx
│   └── page.tsx
├── components/                   # UI Components (Layer 1)
│   ├── ui/                       # shadcn/ui components
│   ├── treatment-plan/
│   ├── patient/
│   └── shared/
├── hooks/                        # Custom Hooks (Layer 2)
│   ├── use-treatment-plan.ts
│   ├── use-patient.ts
│   └── use-drug-interaction.ts
├── lib/
│   ├── services/                 # Services Layer (Layer 3)
│   │   ├── treatment-plan.service.ts
│   │   ├── patient.service.ts
│   │   ├── drug-interaction.service.ts
│   │   └── ai.service.ts
│   ├── utils.ts
│   └── generated/
│       └── prisma/               # Prisma generated client
├── prisma/
│   └── schema.prisma             # Database schema
├── public/                       # Static assets
└── types/                        # TypeScript type definitions
```

### 4.6 Key Architectural Principles

1. **Separation of Concerns**: Each layer has a distinct responsibility
2. **Unidirectional Data Flow**: Clear data flow direction (fetching vs. mutations)
3. **Type Safety**: TypeScript throughout all layers
4. **Reusability**: Services and hooks are reusable across components
5. **Testability**: Each layer can be tested independently
6. **Scalability**: Easy to add new features by following the pattern

### 4.7 Developer Onboarding Checklist

For new developers joining the project:

1. **Environment Setup**
   - Install Node.js and npm
   - Clone repository
   - Run `npm install`
   - Set up environment variables (`.env.local`)
   - Run Prisma migrations: `npx prisma migrate dev`
   - Start dev server: `npm run dev`

2. **Understanding the Codebase**
   - Read this documentation (cursor.mdc)
   - Review Prisma schema to understand data model
   - Explore existing components in `app/` and `components/`
   - Understand the four-layer architecture pattern

3. **Development Workflow**
   - Follow the data flow patterns (fetching vs. mutations)
   - Create services in `lib/services/` for business logic
   - Create hooks in `hooks/` for component integration
   - Use Prisma for all database operations
   - Follow TypeScript best practices

4. **Key Files to Review**
   - `prisma/schema.prisma` - Database schema
   - `app/layout.tsx` - Root layout
   - `components.json` - UI component configuration
   - This file (`cursor.mdc`) - Root documentation

---

## 5. Next Steps for Development

### Immediate Priorities
1. Set up authentication with Next-Auth
2. Implement Prisma schema for patients, treatment plans, and drug interactions
3. Create API routes following the four-layer pattern
4. Build UI components for the multi-step wizard
5. Integrate Gemini AI for treatment plan generation
6. Integrate drug interaction database/API

### Future Enhancements
- Real-time collaboration features
- Advanced analytics and reporting
- Mobile application
- Integration with Electronic Health Records (EHR) systems
- Machine learning model fine-tuning based on doctor feedback

---

**Last Updated**: [Current Date]
**Maintained By**: Development Team
