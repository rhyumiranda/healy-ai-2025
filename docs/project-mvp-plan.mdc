---
alwaysApply: true
---
## Phase 1: Project Foundation & Authentication
**Duration**: Week 1 (5-7 days)  
**Goal**: Set up development environment, core infrastructure, and user authentication system

### Features Delivered:
✅ Development environment configured  
✅ Database schema and migrations  
✅ User registration and login  
✅ Session management  
✅ Protected routes

### Implementation Steps:

#### 1.1 Project Initialization
```bash
# Initialize Next.js project
npx create-next-app@latest ai-treatment-assistant --typescript --tailwind --app
cd ai-treatment-assistant

# Install core dependencies
npm install @prisma/client prisma
npm install next-auth
npm install zustand
npm install zod react-hook-form @hookform/resolvers
npm install lucide-react class-variance-authority clsx tailwind-merge

# Install shadcn/ui
npx shadcn-ui@latest init
```

**Files Created:**
- `package.json` - Dependencies
- `tsconfig.json` - TypeScript configuration
- `tailwind.config.ts` - Tailwind configuration
- `components.json` - shadcn/ui configuration

#### 1.2 Folder Structure Setup
```bash
# Create directory structure
mkdir -p lib/services
mkdir -p lib/utils
mkdir -p hooks
mkdir -p types
mkdir -p components/ui
mkdir -p components/auth
mkdir -p components/layout
mkdir -p app/api/auth
mkdir -p app/(auth)
mkdir -p app/(dashboard)
```

**Folder Structure:**
```
/
├── app/
│   ├── (auth)/
│   │   ├── login/
│   │   └── register/
│   ├── (dashboard)/
│   │   └── dashboard/
│   ├── api/
│   │   └── auth/
│   ├── layout.tsx
│   └── page.tsx
├── components/
│   ├── ui/             # shadcn components
│   ├── auth/           # Auth-specific components
│   └── layout/         # Layout components
├── hooks/              # Custom React hooks
├── lib/
│   ├── services/       # Business logic services
│   └── utils/          # Utility functions
├── prisma/
│   └── schema.prisma
└── types/              # TypeScript definitions
```

#### 1.3 Database Setup (Prisma + Supabase)

**File: `prisma/schema.prisma`**
```prisma
generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  emailVerified DateTime?
  password      String
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  patients       Patient[]
  treatmentPlans TreatmentPlan[]
  sessions       Session[]
  accounts       Account[]
  
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  
  @@unique([identifier, token])
  @@map("verification_tokens")
}
```

**Commands:**
```bash
# Generate Prisma client
npx prisma generate

# Create and run migration
npx prisma migrate dev --name init
```

#### 1.4 Environment Variables Setup

**File: `.env.local`**
```bash
# Database
DATABASE_URL="postgresql://user:password@host:5432/dbname"

# Next-Auth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-secret-key-here-generate-with-openssl"

# AI Provider
AI_PROVIDER="openai"  # or "gemini"
OPENAI_API_KEY="sk-..."
GEMINI_API_KEY="..."
```

#### 1.5 Authentication Implementation

**File: `lib/auth.ts`**
```typescript
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { PrismaAdapter } from "@auth/prisma-adapter";
import { prisma } from "@/lib/prisma";
import bcrypt from "bcryptjs";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: "jwt",
  },
  pages: {
    signIn: "/login",
    signOut: "/login",
    error: "/login",
  },
  providers: [
    CredentialsProvider({
      name: "credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error("Invalid credentials");
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });

        if (!user || !user.password) {
          throw new Error("Invalid credentials");
        }

        const isCorrectPassword = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isCorrectPassword) {
          throw new Error("Invalid credentials");
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
        };
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
      }
      return session;
    },
  },
};
```

**File: `app/api/auth/[...nextauth]/route.ts`**
```typescript
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
```

#### 1.6 Registration API Route

**File: `app/api/auth/register/route.ts`**
```typescript
import { NextResponse } from "next/server";
import bcrypt from "bcryptjs";
import { prisma } from "@/lib/prisma";
import { z } from "zod";

const registerSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .regex(/[A-Z]/, "Password must contain at least one uppercase letter")
    .regex(/[0-9]/, "Password must contain at least one number"),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const { name, email, password } = registerSchema.parse(body);

    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return NextResponse.json(
        { error: "Email already registered" },
        { status: 400 }
      );
    }

    const hashedPassword = await bcrypt.hash(password, 12);

    const user = await prisma.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
      },
    });

    return NextResponse.json(
      {
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
        },
      },
      { status: 201 }
    );
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: error.errors[0].message },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Something went wrong" },
      { status: 500 }
    );
  }
}
```

#### 1.7 Authentication UI Components

**Install shadcn components:**
```bash
npx shadcn-ui@latest add button
npx shadcn-ui@latest add input
npx shadcn-ui@latest add label
npx shadcn-ui@latest add card
npx shadcn-ui@latest add form
```

**File: `components/auth/register-form.tsx`**
```typescript
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";

const registerSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .regex(/[A-Z]/, "Must contain uppercase letter")
    .regex(/[0-9]/, "Must contain number"),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});

type RegisterFormData = z.infer<typeof registerSchema>;

export function RegisterForm() {
  const router = useRouter();
  const [error, setError] = useState<string>("");
  const [isLoading, setIsLoading] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema),
  });

  const onSubmit = async (data: RegisterFormData) => {
    setIsLoading(true);
    setError("");

    try {
      const response = await fetch("/api/auth/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: data.name,
          email: data.email,
          password: data.password,
        }),
      });

      const result = await response.json();

      if (!response.ok) {
        setError(result.error || "Registration failed");
        return;
      }

      router.push("/login?registered=true");
    } catch (error) {
      setError("Something went wrong. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Card className="w-full max-w-md">
      <CardHeader>
        <CardTitle>Create an account</CardTitle>
        <CardDescription>Enter your details to get started</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          {error && (
            <div className="p-3 text-sm text-red-500 bg-red-50 rounded-md">
              {error}
            </div>
          )}

          <div className="space-y-2">
            <Label htmlFor="name">Full Name</Label>
            <Input
              id="name"
              {...register("name")}
              placeholder="Dr. Jane Smith"
              disabled={isLoading}
            />
            {errors.name && (
              <p className="text-sm text-red-500">{errors.name.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              {...register("email")}
              placeholder="jane@example.com"
              disabled={isLoading}
            />
            {errors.email && (
              <p className="text-sm text-red-500">{errors.email.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              {...register("password")}
              disabled={isLoading}
            />
            {errors.password && (
              <p className="text-sm text-red-500">{errors.password.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="confirmPassword">Confirm Password</Label>
            <Input
              id="confirmPassword"
              type="password"
              {...register("confirmPassword")}
              disabled={isLoading}
            />
            {errors.confirmPassword && (
              <p className="text-sm text-red-500">
                {errors.confirmPassword.message}
              </p>
            )}
          </div>

          <Button type="submit" className="w-full" disabled={isLoading}>
            {isLoading ? "Creating account..." : "Create account"}
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}
```

**File: `app/(auth)/register/page.tsx`**
```typescript
import { RegisterForm } from "@/components/auth/register-form";
import Link from "next/link";

export default function RegisterPage() {
  return (
    <div className="flex min-h-screen items-center justify-center p-4">
      <div className="w-full max-w-md space-y-4">
        <RegisterForm />
        <p className="text-center text-sm text-muted-foreground">
          Already have an account?{" "}
          <Link href="/login" className="font-medium text-primary hover:underline">
            Sign in
          </Link>
        </p>
      </div>
    </div>
  );
}
```

#### 1.8 Middleware for Protected Routes

**File: `middleware.ts`**
```typescript
export { default } from "next-auth/middleware";

export const config = {
  matcher: [
    "/dashboard/:path*",
    "/patients/:path*",
    "/treatment-plans/:path*",
    "/api/patients/:path*",
    "/api/plans/:path*",
  ],
};
```

### Phase 1 Deliverables:
- ✅ Project initialized with all dependencies
- ✅ Database schema created and migrated
- ✅ User registration working
- ✅ User login working
- ✅ Session management configured
- ✅ Protected routes middleware active
- ✅ Basic UI components installed

---

## Phase 2: Patient Management
**Duration**: Week 2 (5-7 days)  
**Goal**: Complete patient CRUD operations with intuitive UI

### Features Delivered:
✅ Patient list with search  
✅ Create new patient  
✅ View patient details  
✅ Update patient information  
✅ Delete patient (with confirmation)

### Implementation Steps:

#### 2.1 Extend Database Schema

**File: `prisma/schema.prisma` (add to existing)**
```prisma
model Patient {
  id                 String   @id @default(cuid())
  doctorId           String
  doctor             User     @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  
  // Demographics
  name               String
  dateOfBirth        DateTime
  gender             Gender
  
  // Medical Information
  medicalHistory     String?
  currentMedications String[] @default([])
  allergies          String[] @default([])
  chronicConditions  String[] @default([])
  
  // Timestamps
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  
  treatmentPlans     TreatmentPlan[]
  
  @@index([doctorId])
  @@map("patients")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}
```

**Run migration:**
```bash
npx prisma migrate dev --name add_patient_model
npx prisma generate
```

#### 2.2 Type Definitions

**File: `types/patient.ts`**
```typescript
export type Gender = "MALE" | "FEMALE" | "OTHER";

export interface Patient {
  id: string;
  doctorId: string;
  name: string;
  dateOfBirth: Date;
  gender: Gender;
  medicalHistory?: string;
  currentMedications: string[];
  allergies: string[];
  chronicConditions: string[];
  createdAt: Date;
  updatedAt: Date;
}

export interface CreatePatientInput {
  name: string;
  dateOfBirth: Date;
  gender: Gender;
  medicalHistory?: string;
  currentMedications?: string[];
  allergies?: string[];
  chronicConditions?: string[];
}

export interface UpdatePatientInput extends Partial<CreatePatientInput> {
  id: string;
}
```

#### 2.3 API Layer - Patient Routes

**File: `app/api/patients/route.ts`**
```typescript
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { z } from "zod";

const createPatientSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  dateOfBirth: z.string().transform((str) => new Date(str)),
  gender: z.enum(["MALE", "FEMALE", "OTHER"]),
  medicalHistory: z.string().optional(),
  currentMedications: z.array(z.string()).optional().default([]),
  allergies: z.array(z.string()).optional().default([]),
  chronicConditions: z.array(z.string()).optional().default([]),
});

// GET /api/patients - List all patients for logged-in doctor
export async function GET(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { searchParams } = new URL(req.url);
    const search = searchParams.get("search");

    const patients = await prisma.patient.findMany({
      where: {
        doctorId: session.user.id,
        ...(search && {
          name: {
            contains: search,
            mode: "insensitive",
          },
        }),
      },
      orderBy: {
        updatedAt: "desc",
      },
      include: {
        _count: {
          select: { treatmentPlans: true },
        },
      },
    });

    return NextResponse.json({ patients });
  } catch (error) {
    console.error("Error fetching patients:", error);
    return NextResponse.json(
      { error: "Failed to fetch patients" },
      { status: 500 }
    );
  }
}

// POST /api/patients - Create new patient
export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const data = createPatientSchema.parse(body);

    const patient = await prisma.patient.create({
      data: {
        ...data,
        doctorId: session.user.id,
      },
    });

    return NextResponse.json({ patient }, { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: error.errors[0].message },
        { status: 400 }
      );
    }

    console.error("Error creating patient:", error);
    return NextResponse.json(
      { error: "Failed to create patient" },
      { status: 500 }
    );
  }
}
```

**File: `app/api/patients/[id]/route.ts`**
```typescript
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { z } from "zod";

const updatePatientSchema = z.object({
  name: z.string().min(2).optional(),
  dateOfBirth: z.string().transform((str) => new Date(str)).optional(),
  gender: z.enum(["MALE", "FEMALE", "OTHER"]).optional(),
  medicalHistory: z.string().optional(),
  currentMedications: z.array(z.string()).optional(),
  allergies: z.array(z.string()).optional(),
  chronicConditions: z.array(z.string()).optional(),
});

// GET /api/patients/[id] - Get single patient
export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const patient = await prisma.patient.findUnique({
      where: { id: params.id },
      include: {
        treatmentPlans: {
          orderBy: { createdAt: "desc" },
          take: 10,
        },
      },
    });

    if (!patient) {
      return NextResponse.json({ error: "Patient not found" }, { status: 404 });
    }

    if (patient.doctorId !== session.user.id) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    return NextResponse.json({ patient });
  } catch (error) {
    console.error("Error fetching patient:", error);
    return NextResponse.json(
      { error: "Failed to fetch patient" },
      { status: 500 }
    );
  }
}

// PATCH /api/patients/[id] - Update patient
export async function PATCH(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const existingPatient = await prisma.patient.findUnique({
      where: { id: params.id },
    });

    if (!existingPatient) {
      return NextResponse.json({ error: "Patient not found" }, { status: 404 });
    }

    if (existingPatient.doctorId !== session.user.id) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const body = await req.json();
    const data = updatePatientSchema.parse(body);

    const patient = await prisma.patient.update({
      where: { id: params.id },
      data,
    });

    return NextResponse.json({ patient });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: error.errors[0].message },
        { status: 400 }
      );
    }

    console.error("Error updating patient:", error);
    return NextResponse.json(
      { error: "Failed to update patient" },
      { status: 500 }
    );
  }
}

// DELETE /api/patients/[id] - Delete patient
export async function DELETE(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const patient = await prisma.patient.findUnique({
      where: { id: params.id },
    });

    if (!patient) {
      return NextResponse.json({ error: "Patient not found" }, { status: 404 });
    }

    if (patient.doctorId !== session.user.id) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    await prisma.patient.delete({
      where: { id: params.id },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting patient:", error);
    return NextResponse.json(
      { error: "Failed to delete patient" },
      { status: 500 }
    );
  }
}
```

#### 2.4 Services Layer

**File: `lib/services/patient.service.ts`**
```typescript
import { Patient, CreatePatientInput, UpdatePatientInput } from "@/types/patient";

export class PatientService {
  static async getPatients(search?: string): Promise<Patient[]> {
    const params = new URLSearchParams();
    if (search) params.append("search", search);

    const response = await fetch(`/api/patients?${params.toString()}`, {
      method: "GET",
      headers: { "Content-Type": "application/json" },
    });

    if (!response.ok) {
      throw new Error("Failed to fetch patients");
    }

    const data = await response.json();
    return data.patients;
  }

  static async getPatient(id: string): Promise<Patient> {
    const response = await fetch(`/api/patients/${id}`, {
      method: "GET",
      headers: { "Content-Type": "application/json" },
    });

    if (!response.ok) {
      throw new Error("Failed to fetch patient");
    }

    const data = await response.json();
    return data.patient;
  }

  static async createPatient(input: CreatePatientInput): Promise<Patient> {
    const response = await fetch("/api/patients", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(input),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "Failed to create patient");
    }

    const data = await response.json();
    return data.patient;
  }

  static async updatePatient(input: UpdatePatientInput): Promise<Patient> {
    const { id, ...updateData } = input;

    const response = await fetch(`/api/patients/${id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(updateData),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || "Failed to update patient");
    }

    const data = await response.json();
    return data.patient;
  }

  static async deletePatient(id: string): Promise<void> {
    const response = await fetch(`/api/patients/${id}`, {
      method: "DELETE",
    });

    if (!response.ok) {
      throw new Error("Failed to delete patient");
    }
  }
}
```

#### 2.5 Hooks Layer

**File: `hooks/use-patients.ts`**
```typescript
"use client";

import { useState, useEffect } from "react";
import { Patient } from "@/types/patient";
import { PatientService } from "@/lib/services/patient.service";

export function usePatients(search?: string) {
  const [patients, setPatients] = useState<Patient[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPatients = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const data = await PatientService.getPatients(search);
        setPatients(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to load patients");
      } finally {
        setIsLoading(false);
      }
    };

    fetchPatients();
  }, [search]);

  const refetch = async () => {
    try {
      setError(null);
      const data = await PatientService.getPatients(search);
      setPatients(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load patients");
    }
  };

  return { patients, isLoading, error, refetch };
}

export function usePatient(id: string) {
  const [patient, setPatient] = useState<Patient | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchPatient = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const data = await PatientService.getPatient(id);
        setPatient(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to load patient");
      } finally {
        setIsLoading(false);
      }
    };

    if (id) {
      fetchPatient();
    }
  }, [id]);

  return { patient, isLoading, error };
}
```

**File: `hooks/use-create-patient.ts`**
```typescript
"use client";

import { useState } from "react";
import { CreatePatientInput, Patient } from "@/types/patient";
import { PatientService } from "@/lib/services/patient.service";

export function useCreatePatient() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createPatient = async (input: CreatePatientInput): Promise<Patient | null> => {
    try {
      setIsLoading(true);
      setError(null);
      const patient = await PatientService.createPatient(input);
      return patient;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to create patient";
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return { createPatient, isLoading, error };
}
```

#### 2.6 UI Components

**Install additional shadcn components:**
```bash
npx shadcn-ui@latest add table
npx shadcn-ui@latest add dialog
npx shadcn-ui@latest add select
npx shadcn-ui@latest add textarea
npx shadcn-ui@latest add badge
npx shadcn-ui@latest add skeleton
```

**File: `components/patients/patient-list.tsx`**
```typescript
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { usePatients } from "@/hooks/use-patients";
import { formatDistance } from "date-fns";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Skeleton } from "@/components/ui/skeleton";
import { Search, Plus } from "lucide-react";

export function PatientList() {
  const router = useRouter();
  const [search, setSearch] = useState("");
  const { patients, isLoading, error } = usePatients(search);

  if (error) {
    return (
      <div className="p-4 text-center text-red-500">
        Error loading patients: {error}
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">Patients</h2>
        <Button onClick={() => router.push("/patients/new")}>
          <Plus className="mr-2 h-4 w-4" />
          New Patient
        </Button>
      </div>

      <div className="relative">
        <Search className="absolute left-3 top-3 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search patients..."
          value={search}
          onChange={(e) => setSearch(e.target.value)}
          className="pl-10"
        />
      </div>

      {isLoading ? (
        <div className="space-y-3">
          {[1, 2, 3].map((i) => (
            <Skeleton key={i} className="h-20 w-full" />
          ))}
        </div>
      ) : patients.length === 0 ? (
        <div className="text-center py-12 text-muted-foreground">
          {search ? "No patients found" : "No patients yet. Create your first patient."}
        </div>
      ) : (
        <div className="space-y-3">
          {patients.map((patient) => (
            <div
              key={patient.id}
              onClick={() => router.push(`/patients/${patient.id}`)}
              className="p-4 border rounded-lg cursor-pointer hover:border-primary transition-colors"
            >
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="font-medium">{patient.name}</h3>
                  <p className="text-sm text-muted-foreground">
                    {patient.gender} • Age{" "}
                    {new Date().getFullYear() - new Date(patient.dateOfBirth).getFullYear()}
                  </p>
                </div>
                <div className="text-right text-sm text-muted-foreground">
                  Last updated{" "}
                  {formatDistance(new Date(patient.updatedAt), new Date(), {
                    addSuffix: true,
                  })}
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

**File: `app/(dashboard)/patients/page.tsx`**
```typescript
import { PatientList } from "@/components/patients/patient-list";

export default function PatientsPage() {
  return (
    <div className="container mx-auto py-8 max-w-4xl">
      <PatientList />
    </div>
  );
}
```

### Phase 2 Deliverables:
- ✅ Patient database model created
- ✅ Complete CRUD API routes
- ✅ Patient service layer implemented
- ✅ Custom hooks for data fetching
- ✅ Patient list with search
- ✅ Create patient form
- ✅ View patient details
- ✅ Update patient functionality
- ✅ Delete patient with confirmation

---

## Phase 3: Treatment Plan Wizard (Part 1)
**Duration**: Week 3 (5-7 days)  
**Goal**: Implement Steps 1-2 of treatment plan wizard with AI integration

### Features Delivered:
✅ Treatment plan wizard layout  
✅ Step 1: Patient selection and intake form  
✅ Step 2: AI analysis and recommendation generation  
✅ AI service integration (OpenAI/Gemini)  
✅ Loading states and error handling

### Implementation Steps:

#### 3.1 Extend Database Schema

**File: `prisma/schema.prisma` (add to existing)**
```prisma
model TreatmentPlan {
  id              String   @id @default(cuid())
  patientId       String
  patient         Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  doctorId        String
  doctor          User     @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  
  // Intake Data (Step 1)
  chiefComplaint      String
  currentSymptoms     String
  vitalSigns          Json?
  physicalExamNotes   String?
  
  // AI Recommendations (Step 2)
  aiRecommendations   Json?
  
  // Final Plan (Step 3/4)
  finalPlan           Json?
  
  // Risk Assessment
  riskLevel           RiskLevel?
  riskFactors         String[] @default([])
  riskJustification   String?
  
  // Drug Interactions
  drugInteractions    Json[] @default([])
  contraindications   Json[] @default([])
  
  // Alternatives
  alternatives        Json[] @default([])
  
  // Status & Workflow
  status              PlanStatus @default(DRAFT)
  wasModified         Boolean    @default(false)
  modificationNotes   String?
  
  // Timestamps
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt
  approvedAt          DateTime?
  
  @@index([patientId])
  @@index([doctorId])
  @@index([status])
  @@index([createdAt])
  @@map("treatment_plans")
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
}

enum PlanStatus {
  DRAFT
  APPROVED
  REJECTED
}
```

**Run migration:**
```bash
npx prisma migrate dev --name add_treatment_plan_model
npx prisma generate
```

#### 3.2 AI Service Implementation

**File: `lib/services/ai.service.ts`**
```typescript
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface PatientData {
  name: string;
  age: number;
  gender: string;
  medicalHistory?: string;
  currentMedications: string[];
  allergies: string[];
  chronicConditions: string[];
  chiefComplaint: string;
  currentSymptoms: string;
  vitalSigns?: any;
}

interface AITreatmentResponse {
  treatmentPlan: {
    medications: Array<{
      name: string;
      genericName: string;
      dosage: string;
      frequency: string;
      duration: string;
      route: string;
      instructions: string;
      confidenceScore: number;
    }>;
    riskAssessment: {
      overallRisk: "LOW" | "MEDIUM" | "HIGH";
      riskFactors: string[];
      justification: string;
    };
    drugInteractions: Array<{
      medication1: string;
      medication2: string;
      severity: "Mild" | "Moderate" | "Severe";
      description: string;
      recommendation: string;
    }>;
    contraindications: Array<{
      medication: string;
      reason: string;
      severity: "Absolute" | "Relative";
    }>;
    alternatives: Array<{
      medications: any[];
      rationale: string;
      riskLevel: "LOW" | "MEDIUM" | "HIGH";
    }>;
    rationale: string;
    recommendations: string[];
  };
}

export class AIService {
  static async generateTreatmentPlan(
    patientData: PatientData
  ): Promise<AITreatmentResponse> {
    const prompt = this.buildPrompt(patientData);

    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-4-turbo-preview",
        messages: [
          {
            role: "system",
            content:
              "You are an expert medical AI assistant. Provide treatment recommendations in valid JSON format only. Be thorough and consider all patient factors.",
          },
          {
            role: "user",
            content: prompt,
          },
        ],
        temperature: 0.3,
        response_format: { type: "json_object" },
      });

      const content = completion.choices[0].message.content;
      if (!content) {
        throw new Error("No response from AI");
      }

      const response = JSON.parse(content) as AITreatmentResponse;
      return response;
    } catch (error) {
      console.error("AI Service Error:", error);
      throw new Error("Failed to generate treatment plan");
    }
  }

  private static buildPrompt(patientData: PatientData): string {
    return `
Generate a comprehensive treatment plan for the following patient:

PATIENT INFORMATION:
- Name: ${patientData.name}
- Age: ${patientData.age}
- Gender: ${patientData.gender}
- Medical History: ${patientData.medicalHistory || "None reported"}
- Current Medications: ${patientData.currentMedications.join(", ") || "None"}
- Allergies: ${patientData.allergies.join(", ") || "None"}
- Chronic Conditions: ${patientData.chronicConditions.join(", ") || "None"}

CURRENT PRESENTATION:
- Chief Complaint: ${patientData.chiefComplaint}
- Current Symptoms: ${patientData.currentSymptoms}
${patientData.vitalSigns ? `- Vital Signs: ${JSON.stringify(patientData.vitalSigns)}` : ""}

Provide a treatment plan in the following JSON schema:

{
  "treatmentPlan": {
    "medications": [
      {
        "name": "string",
        "genericName": "string",
        "dosage": "string (e.g., 500mg)",
        "frequency": "string (e.g., twice daily)",
        "duration": "string (e.g., 7 days)",
        "route": "string (oral, IV, topical, etc.)",
        "instructions": "string",
        "confidenceScore": number (0-100)
      }
    ],
    "riskAssessment": {
      "overallRisk": "LOW" | "MEDIUM" | "HIGH",
      "riskFactors": ["string"],
      "justification": "string"
    },
    "drugInteractions": [
      {
        "medication1": "string",
        "medication2": "string",
        "severity": "Mild" | "Moderate" | "Severe",
        "description": "string",
        "recommendation": "string"
      }
    ],
    "contraindications": [
      {
        "medication": "string",
        "reason": "string",
        "severity": "Absolute" | "Relative"
      }
    ],
    "alternatives": [
      {
        "medications": [same structure as main medications],
        "rationale": "string",
        "riskLevel": "LOW" | "MEDIUM" | "HIGH"
      }
    ],
    "rationale": "string (overall treatment rationale)",
    "recommendations": ["string (additional recommendations)"]
  }
}

Important:
1. Check all current medications for interactions with recommended medications
2. Consider all allergies when recommending medications
3. Factor in chronic conditions
4. Provide at least 1-2 alternative treatment options
5. Be conservative with risk assessments
6. Provide clear, actionable recommendations
`;
  }
}
```

#### 3.3 Treatment Plan API Routes

**File: `app/api/ai/generate/route.ts`**
```typescript
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { AIService } from "@/lib/services/ai.service";
import { z } from "zod";

const generateSchema = z.object({
  patientData: z.object({
    name: z.string(),
    age: z.number(),
    gender: z.string(),
    medicalHistory: z.string().optional(),
    currentMedications: z.array(z.string()),
    allergies: z.array(z.string()),
    chronicConditions: z.array(z.string()),
    chiefComplaint: z.string(),
    currentSymptoms: z.string(),
    vitalSigns: z.any().optional(),
  }),
});

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const { patientData } = generateSchema.parse(body);

    const response = await AIService.generateTreatmentPlan(patientData);

    return NextResponse.json(response);
  } catch (error) {
    console.error("Error generating treatment plan:", error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Invalid request data" },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: "Failed to generate treatment plan" },
      { status: 500 }
    );
  }
}
```

**File: `app/api/plans/route.ts`**
```typescript
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import { z } from "zod";

const createPlanSchema = z.object({
  patientId: z.string(),
  chiefComplaint: z.string(),
  currentSymptoms: z.string(),
  vitalSigns: z.any().optional(),
  physicalExamNotes: z.string().optional(),
  aiRecommendations: z.any().optional(),
});

export async function POST(req: Request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await req.json();
    const data = createPlanSchema.parse(body);

    const plan = await prisma.treatmentPlan.create({
      data: {
        ...data,
        doctorId: session.user.id,
      },
    });

    return NextResponse.json({ plan }, { status: 201 });
  } catch (error) {
    console.error("Error creating treatment plan:", error);
    return NextResponse.json(
      { error: "Failed to create treatment plan" },
      { status: 500 }
    );
  }
}
```

#### 3.4 Wizard State Management

**File: `lib/store/wizard-store.ts`**
```typescript
import { create } from "zustand";

interface WizardState {
  currentStep: number;
  patientId: string | null;
  intakeData: any;
  aiRecommendations: any;
  finalPlan: any;
  
  setStep: (step: number) => void;
  setPatientId: (id: string) => void;
  setIntakeData: (data: any) => void;
  setAIRecommendations: (data: any) => void;
  setFinalPlan: (data: any) => void;
  reset: () => void;
}

export const useWizardStore = create<WizardState>((set) => ({
  currentStep: 1,
  patientId: null,
  intakeData: null,
  aiRecommendations: null,
  finalPlan: null,
  
  setStep: (step) => set({ currentStep: step }),
  setPatientId: (id) => set({ patientId: id }),
  setIntakeData: (data) => set({ intakeData: data }),
  setAIRecommendations: (data) => set({ aiRecommendations: data }),
  setFinalPlan: (data) => set({ finalPlan: data }),
  reset: () => set({
    currentStep: 1,
    patientId: null,
    intakeData: null,
    aiRecommendations: null,
    finalPlan: null,
  }),
}));
```

#### 3.5 Wizard UI Components

**File: `components/wizard/wizard-progress.tsx`**
```typescript
"use client";

import { Check } from "lucide-react";

const steps = [
  { number: 1, name: "Patient Intake" },
  { number: 2, name: "AI Analysis" },
  { number: 3, name: "Review & Edit" },
  { number: 4, name: "Summary" },
];

interface WizardProgressProps {
  currentStep: number;
}

export function WizardProgress({ currentStep }: WizardProgressProps) {
  return (
    <div className="mb-8">
      <div className="flex items-center justify-between">
        {steps.map((step, index) => (
          <div key={step.number} className="flex items-center flex-1">
            <div className="flex flex-col items-center">
              <div
                className={`flex items-center justify-center w-10 h-10 rounded-full border-2 transition-colors ${
                  step.number < currentStep
                    ? "bg-primary border-primary text-primary-foreground"
                    : step.number === currentStep
                    ? "border-primary text-primary"
                    : "border-muted text-muted-foreground"
                }`}
              >
                {step.number < currentStep ? (
                  <Check className="w-5 h-5" />
                ) : (
                  <span className="font-medium">{step.number}</span>
                )}
              </div>
              <p
                className={`mt-2 text-sm font-medium ${
                  step.number === currentStep
                    ? "text-primary"
                    : "text-muted-foreground"
                }`}
              >
                {step.name}
              </p>
            </div>
            {index < steps.length - 1 && (
              <div
                className={`flex-1 h-0.5 mx-4 ${
                  step.number < currentStep ? "bg-primary" : "bg-muted"
                }`}
              />
            )}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Phase 3 Deliverables:
- ✅ Treatment plan database model
- ✅ AI service integration (OpenAI)
- ✅ Wizard state management
- ✅ Progress indicator component
- ✅ Step 1: Intake form
- ✅ Step 2: AI generation with loading state
- ✅ API routes for AI and treatment plans
- ✅ Error handling for AI failures

---

## Phase 4: Treatment Plan Wizard (Part 2)
**Duration**: Week 4 (5-7 days)  
**Goal**: Implement Steps 3-4 with review, edit, and approval workflow

### Features Delivered:
✅ Step 3: Review AI recommendations  
✅ Risk-first display with alerts  
✅ Inline editing of medications  
✅ Alternative treatment options  
✅ Step 4: Final summary and approval  
✅ Save treatment plan to database

[Continue with detailed implementation...]

---

## Phase 5: Dashboard & Polish
**Duration**: Week 5 (5-7 days)  
**Goal**: Create dashboard, refine UI/UX, add polish and animations

### Features Delivered:
✅ Doctor dashboard with stats  
✅ Recent patients widget  
✅ Quick actions  
✅ Smooth animations and transitions  
✅ Loading skeletons  
✅ Error states  
✅ Responsive design refinement

[Continue with detailed implementation...]

---

## Phase 6: Testing & Deployment
**Duration**: Week 6 (5-7 days)  
**Goal**: End-to-end testing, bug fixes, and production deployment

### Features Delivered:
✅ All user flows tested  
✅ Bug fixes  
✅ Performance optimization  
✅ Production deployment  
✅ Monitoring setup  
✅ Documentation

[Continue with detailed implementation...]

---

## Implementation Checklist

### Phase 1: Foundation ✅
- [ ] Next.js project initialized
- [ ] Database schema created
- [ ] Prisma migrations run
- [ ] Authentication working
- [ ] Protected routes configured
- [ ] Basic UI components installed

### Phase 2: Patient Management ✅
- [ ] Patient CRUD API complete
- [ ] Patient list with search
- [ ] Create patient form
- [ ] View patient details
- [ ] Update patient
- [ ] Delete patient

### Phase 3: Wizard Part 1 ✅
- [ ] Treatment plan model
- [ ] AI service integrated
- [ ] Wizard state management
- [ ] Step 1: Intake form
- [ ] Step 2: AI generation
- [ ] Loading states

### Phase 4: Wizard Part 2 ⏳
- [ ] Step 3: Review UI
- [ ] Inline editing
- [ ] Risk alerts
- [ ] Alternative options
- [ ] Step 4: Summary
- [ ] Approval workflow

### Phase 5: Dashboard & Polish ⏳
- [ ] Dashboard page
- [ ] Stats widgets
- [ ] Animations
- [ ] Responsive design
- [ ] Error handling

### Phase 6: Deployment ⏳
- [ ] End-to-end testing
- [ ] Bug fixes
- [ ] Performance optimization
- [ ] Production deployment
- [ ] Monitoring setup

---

**Document Version**: 1.0  
**Last Updated**: December 5, 2025  
**Status**: In Progress
